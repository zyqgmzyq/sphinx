# Java虚拟机

## 1 编译器和解释器

编译器的主要功能：把高阶语言写的源程序翻译成具体的机器语言

解释器：将程序翻译成为一系列用来执行程序的动作，能够发现runtime中的逻辑错误，并找到出错位置

JIT（Just In Time）编译器

编译型语言：把做好的源程序全部编译成二进制代码的可运行程序，然后，可以直接运行这个程序

解释型语言：把源程序翻译一句，然后执行一句，直至结束。

二者各有优势，当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即执行；当程序运行后，随着时间的推移，编译器逐渐会返回作用，把越来越多的代码编译成本地代码后，可以获取更高的执行效率。

## 2 HotSpot Vm

### 热点代码探测技术

把反复多次执行的代码编译成机器码，下次执行的时候就可以直接执行而不再触发解释，以提高程序的运行效率。热点代码探测对象：多次执行的方法和循环体。

JIT编译器对于经常使用的字节码（hotspot），会把包含该代码的整个方法为单位，一次性整个方法的字节码编译成本地字节码然后直接运行编译之后的机器码。

对象：1 被多次调用的方法-标准JIT编译 2 被多次调用的循环体-发生在方法的执行中，称栈上替换（OSR）

#### 方法：方法调用计数器

原则：为每个方法（甚至是代码块）建立计数器，执行次数超过阈值就认为是热点方法

计数器：相对频率，在一定的时间限度内，该方法被调用的次数，超出该时间段未达到阈值，计数器减半—热度衰减的周期成为半周期，该过程在垃圾回收顺便执行

阈值：1500 on client 10000 on server

参数设置：-XX CounterHalfLifeTime 设定半衰期周期时间，-XX CompileThreadhold 设定阈值

#### 循环体：回边计数器

在循环体中添加计数器，执行次数超过阈值就认定是向编译器提交编译请求。

回边指令：字节码中遇到控制流向后跳转的指令称为回边

参数设置：onStackRepalcePercentage 调整阈值

#### 编译过程

JVM中同时运行着两条线程

编程线程（编译器）

执行线程（解释器）

用户可以通过-XX：-BackgroundCompilcation来禁止后台编译，一旦达到JIT的编译条件，执行线程就会先进入等待状态，直到JIT编译完成后执行。

## 3 Java 内存区域与内存溢出异常

在JVM所管理的内存中，大致分为以下几个运行时数据区域

（1）程序计数器：当前线程所执行的字节码的行号指示器

（2）虚拟机栈：Java方法执行的内存模型，用于存储局部变量表、操作数栈、动态链表和方法出口信息等

（3）本地方法栈：本地方法执行的内存模型，和虚拟机栈非常相似，其区别是本地方法栈为JVM使用到的Native方法服务

（4）堆：用于存储对象实例，是垃圾收集器管理的主要区域

（5）方法区：用于存储已被JVM加载的类信息，常量、静态变量、即时编译器编译后的代码等数据

其中，程序计数器、虚拟机栈、本地方法栈是线程私有的，堆和方法区是线程共享的

### 3.1 程序计数器

程序计数器，（Program Counter Register），它是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。

在java虚拟机的概念模型里面，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计算器完成。

假设程序永远只有一个线程，并不需要程序计数器，因为沿着指令的顺序执行下去，即使是分支跳转这样的流程，跳转到指定的指令处按顺序继续执行是完全能够保证程序的执行顺序的。

JVM的多线程是通过时间片轮转算法实现的，即线程轮流切换并分配处理器执行时间。在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。也就是说，某个线程在执行过程中可能会因为时间片耗尽而被挂起，而另一个线程获取到时间片开始执行。当被挂起的线程重新获取到时间片时候，它想要从被挂起的地方继续执行，就必须知道自己执行到哪个位置。在JVM中，程序计数器就是用来记录某个线程的字节码执行位置。因此，为了线程切换能够恢复到正确的执行位置，每个线程都需要一个独立的程序计数器，即具备线程隔离的特性，各条线程之间计数器互不影响，独立存储（我们称这一类内存区域为线程私有的内存）

【注意】程序计数器记录的值分为两种情况

（1）如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址

（2）如果正在执行的是Native方法，这个计数器值为空（Undefined）

Native方法是Java通过JNI（Java Native Interface）直接调用本地的C/C++库，可以近似的认为Native方法相当于C/C++暴露给Java的一个接口，Java通过这个接口从而调用到C/C++方法，由于该方法时通过C/C++而不是Java进行实现，因而无法产生相对应的字节码，并且C/C++执行时的内存分配是由自己语言决定的，而不是JVM决定。

【程序计数器的特点】

（1）线程隔离性（即程序计数器的内存空间时线程私有的），每个线程工作时都有属于自己的独立计数器

（2）执行Java方法时，程序计数器是有值的，且记录的是正在执行的字节码指令的地址

（3）执行Native方法时，程序计数器的值为空（Undefined）

（4）程序计数器占用内存很小，在进行JVM内存计算时，可以忽略不计

（5）程序计数器，是唯一一个在Java虚拟机规范中没有规定任何OutofMemoryError的区域。程序计数器保存的是当前执行的字节码的偏移地址。当执行到下一条指令的时候，改变的只是程序计数器保存的地址，并不需要申请新的内存来保存新的指令地址，因此，永远都不可能内存溢出。

（6）线程计数器，必须是线程被创建开始执行的时候，就要一同被创建。

Java线程总是需要以某种形式映射到OS线程上。映射模型可以是1:1（原生线程模型）、n:1（绿色线程 / 用户态线程模型）、m:n（混合模型）。以HotSpot VM的实现为例，它目前在大多数平台上都使用1:1模型，也就是每个Java线程都直接映射到一个OS线程上执行。此时，**native方法就由原生平台直接执行**，并不需要理会抽象的JVM层面上的“pc寄存器”概念——原生的CPU上真正的PC寄存器是怎样就是怎样。就像一个用C或C++写的多线程程序，它在线程切换的时候是怎样的，Java的native方法也就是怎样的。

### 3.2 Java虚拟机栈

每一个线程都有自己的虚拟机栈，也是线程私有的，它的生命周期与线程相同，当线程被创建时，虚拟机也同时被创建；当线程被销毁时，虚拟机栈也同时被销毁。

在线程内部，每个方法被执行时都会同时创建一个栈帧（Stack Frame），用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。其中，局部变量表存放着编译器可知的各种基本的数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型）和returnAddress类型（指向了一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

#### 3.2.1 栈与寄存器

虚拟机常见的实现方式有两种：基于栈（Stack Based）和基于寄存器（Register Based）。典型的基于栈的虚拟机有Hotspot VM，.net CLR，而典型的基于寄存器的虚拟机有Lua语言虚拟机LuaVM和Google开发的Android虚拟机DalvikVM。

两者有何不同？例如两数相加的例子a+b，Java源码如下所示：

```Java
int my_add(int a, int b) {
    return a + b;
}
```

使用Javap查看对应的字节，如下所示

```
0: iload_1 // 将 a 压入操作数栈 
1: iload_2 // 将 b 压入操作数栈 
2: iadd    // 将栈顶两个值出栈相加，然后将结果放回栈顶 
3: ireturn // 将栈顶值返回
```

实现相同功能对应的 lua 代码如下

```lua
local function my_add(a, b)
    return a + b;
end
```

使用 luac-l-l-v-s test.lua 命令查看 lua 的字节码，如下所示

```
[1] ADD       R2 R0 R1     ; R2 := R0 + R1
[2] RETURN    R2 2         ; return R2
[3] RETURN    R0 1         ; return 
```

第 1 行调用 ADD 指令将 R0 寄存器和 R1 寄存器中的值相加存储到寄存器 R2 中。第 2 行返回 R2 寄存器的值。第 3 行是 lua 的一个特殊处理，为了防止有分支漏掉了 return 语句，lua 始终在最后插入一行 return 语句。

【优缺点】基于栈和基于寄存器的指令集架构各有优缺点，具体如下所示。

基于栈的指令集架构的优点是移植性更好、指令更短、实现简单，但是不能随机访问堆栈中的元素，完成相同功能所需的指令数一般比寄存器架构多，需要频繁地入栈出栈，不利于代码优化。

基于寄存器的指令集架构的优点是速度快，可以充分利用寄存器，有利于程序做运行速度优化，但操作数需要显式指定，指令较长。

#### 3.2.2 栈帧

栈帧包含：局部变量表、操作数栈、动态链表

在写递归的程序时如果忘记写递归退出的条件，则会报 java.lang.StackOverflowError 异常。比如计算斐波拉契数列，它的计算公式为 f（n）=f（n-1）+f（n-2）在没有递归退出条件的情况下，很容易写出下面的代码

```java
public static int fibonacci(int n) {
    return fibonacci(n - 1) + fibonacci(n - 2);
}
```

运行上面的代码马上会报 java.lang.StackOverflowError 异常。为什么会抛这个异常呢？这就要从栈帧（Stack Frame）讲起。

什么是栈帧呢？栈帧可以理解为一个方法的运行空间。它主要由两部分构成，一部分是局部变量表，方法中定义的局部变量以及方法的参数就存放在这张表中；另一部分是操作数栈，用来存放操作数。我们知道，Java 程序编译之后就变成了一条条字节码指令，其形式类似汇编，但和汇编有不同之处：汇编指令的操作数存放在数据段和寄存器中，可栈中，当执行某条带 n 个操作数的指令时，就从栈顶取 n 个操作数，然后把指令的计算结果（如果有的话）入栈。因此，当我们说 JVM 执行引擎是基于栈的时候，其中的“栈”指的就是操作数栈。

当有一个方法被调用时，代表这个方法的栈帧入栈。当这个方法返回时，其栈帧出栈。因此，虚拟机栈中栈帧的入栈顺序就是方法调用顺序。

Hotspot JVM 是一个基于栈的虚拟机，每个线程都有一个虚拟机栈用来存储栈帧，每次方法调用都伴随着栈帧的创建、销毁。当线程请求分配的栈容量超过Java虚拟机栈允许的最大容量时，Java虚拟机将会抛出StackOverFlowError异常，可以用JVM命令行参数-Xss来指定线程栈的大小，比如-Xss：256用于将 栈的大小设置为256KB。

对比汇编指令和Java字节码指令的执行过程，比如计算1+2时，汇编指令如下：

```
mov ax, 1 ;把 1 放入寄存器 ax
add ax, 2 ;用 ax 的内容和 2 相加后存入 ax
```

而JVM的字节码指令是这样的

```
iconst_1 //把整数 1 压入操作数栈
iconst_2 //把整数 2 压入操作数栈
iadd //栈顶的两个数相加后出栈，结果入栈
```

由于操作数栈是内存空间，所以字节码指令不必担心不同机器上寄存器以及机器指令的差别，从而做到了平台无关。

注意，局部变量表中的变量不可直接使用，如需使用必须通过相关指令将其加载至操作数栈中作为操作数使用。比如有一个方法 void foo()，其中的代码为：int a = 1 + 2; int b = a + 3;，编译为字节码指令就是这样的：

```
iconst_1 //把整数 1 压入操作数栈
iconst_2 //把整数 2 压入操作数栈
iadd //栈顶的两个数出栈后相加，结果入栈；实际上前三步会被编译器优化为：iconst_3
istore_1 //把栈顶的内容放入局部变量表中索引为 1 的 slot 中，也就是 a 对应的空间中
iload_1 // 把局部变量表索引为 1 的 slot 中存放的变量值（3）加载至操作数栈
iconst_3 
iadd //栈顶的两个数出栈后相加，结果入栈
istore_2 // 把栈顶的内容放入局部变量表中索引为 2 的 slot 中，也就是 b 对应的空间中
return // 方法返回指令，回到调用点
```

需要说明的是，局部变量表以及操作数栈的容量的最大值在编译时就已经确定了，运行时不会改变。并且局部变量表的空间是可以复用的，例如，当指令的位置超出了局部变量表中某个变量 a 的作用域时，如果有新的局部变量 b 要被定义，b 就会覆盖 a 在局部变量表的空间。

看完上面的代码大家可能会有几点疑惑：什么是 slot？那些指令是什么意思？为什么 a 对应的 slot 的索引值不是从零开始的，它明明是第一个定义的变量啊？

【Slot】

首先什么是 slot？slot 是局部变量表中的空间单位，虚拟机规范中有规定，对于 32 位之内的数据，用一个 slot 来存放，如 int，short，float 等；对于 64 位的数据用连续的两个 slot 来存放，如 long，double 等。引用类型的变量 JVM 并没有规定其长度，它可能是 32 位，也有可能是 64 位的，所以既有可能占一个 slot，也有可能占两个 slot。

从 Java 语言的层面讲，静态方法和实例方法的本质区别在于是否是对象所共享的。而从 JVM 的角度来看，方法（无论静态方法还是实例方法）其实都是对象共享的，实例变量才是对象私有的。对 JVM 而言，静态方法和实例方法的本质区别在于是否需要和具体对象关联：静态方法可以通过类名来调用，它不需要和具体对象关联；而实例方法必须通过对象来进行调用，它需要和具体对象关联。那么，实例方法和具体对象是如何产生关联的呢？其实很简单，编译器在编译时会将方法接收者作为一个隐含参数传入该实例方法，这个参数在方法中有一个很熟悉的名字，叫做 “this”。之所以实例方法可以访问该类的实例变量和其它实例方法，正是因为它有 “this” 这个隐含参数。举个例子，类 A 中的某个方法 b 需要访问实例变量 x，由于实例变量是对象私有的，如果 b 是静态方法，由于它没有具体对象的引用，它并不知道该访问哪个对象的实例变量 x；如果 b 是实例方法，通过隐含参数 this 就能确定要访问的实例变量是 this.x。那么，为什么静态方法也不能调用该类的实例方法呢？本质原因也是没有 this 引用。因为调用实例方法的前提是要传入一个隐含参数，实例方法本来就有这个引用，所以能够把它作为隐含参数传入另一个实例方法；静态方法没有 this 引用，无法给实例方法提供指向方法接收者的隐含参数，因此不能调用实例方法。

如果看懂了上面说的那些，第三个问题也就迎刃而解了。因为我们定义的方法是 void foo()，它是实例方法，因此会有一个指向具体对象的隐含参数 this，this 就存放在局部变量表的第一个位置，即存放在索引为 0 的 slot 中，又由于它的作用域从方法开始一直到方法结束，因此它在局部变量表中的位置不会被其他变量覆盖，从而使得我们在方法中定义的变量只能放在局部变量表后面的位置中。需要注意的是，如果方法有参数（非隐含参数），那么参数会按顺序紧接着 this 存放在局部变量表中，由于参数作用域也是整个方法体，所以方法中定义的局部变量就只能放在参数后面了。总的来说局部变量表中变量的存放顺序为： this（如果是实例方法）=> 参数（如果有的话）=> 定义的局部变量（如果有的话）。

【JVM 字节码指令】

首先我们要理解 Java 指令的格式，Java 的指令以字节为单位，也就是一个字节代表一条指令。比如 iconst_1 就是一条指令，它占一个字节，那么自然 Java 指令不会超过 256 条。实际上 Java 指令目前定义了 200 多条。指令虽然是一个字节，但是它也可以带自己的操作数。JVM 中有这样一条指令 putstatic，其作用是给特定的的静态字段赋值。但是给哪个字段赋值呢？仅仅通过这条指令并不能说明，那么只有通过操作数来指定了。紧跟在 putstatic 后面的两个字节就是它的操作数，这个操作数是一个索引值，指向运行时常量池中该静态字段对应的符号引用。由于符号引用包含了该字段的基本信息，如所属类、简单名称以及描述符，因此 putstatic 指令就知道是给哪个类的哪个字段赋值了。

指令的操作数分两种：一种是嵌入在指令中的，通常是指令字节后面的若干个字节；另一种是存放在操作数栈中的。为了区别，我们把前者叫做嵌入式操作数，把后者叫做栈内操作数。这两者的区别是：嵌入式操作数是在编译时就已经确定的，运行时不会改变，它和指令一样存放于类文件方法表的 Code 属性中；而操作数是运行时确定的，即程序在执行过程中动态生成的。拿 putstatic 指令来说，它有一个嵌入式操作数，该操作数是一个索引值（前面已经提到），它由两个字节组成，紧跟在 putstatic 对应的字节之后；同时它还有一个栈内操作数，位于操作数栈的栈顶，这个操作数就是要赋给静态字段的值，其对应的字节数根据静态字段的类型决定。如果静态字段的类型是 short、int、boolean、char 或者 byte，那么这个操作数就必须是 int 类型，即由栈顶的 4 个字节组成；如果是 float、double 或者 long 类型，那么操作数就是相应的类型，即由栈顶的 4 个、8 个 或者 8 个 字节组成；如果静态字段是引用类型，那么这个操作数的类型也必须是引用类型，即由栈顶的 8 个字节组成。

再举一个例子。iconst<i>代表了一个指令族，它的意思是把整数 i 放入操作数栈中，i 的范围是(m1, 0, 1, 2, 3, 4, 5)，其中 m1 代表的是 -1。注意，这里的 i 并不是指令的操作数（即非嵌入式操作数，也非栈内操作数），如 iconst_1、iconst_2 和 iconst_3 都是由一个字节组成的字节码指令。我们可以把 i 可以看作是指令的 “隐含操作数”，即指令本身就蕴含了操作数。如果整数 i 超过 [-1, 5] 这个范围，就不能用 iconst_<i> 表示了，因为仅一个字节的字节码指令不可能蕴含所有的整数。此时就需要 bipush 这条指令了，这条指令有一个嵌入式操作数，由一个字节组成，用来表示要放入栈顶的那个整数，该整数放入栈顶时通过扩展符号位变为 32 位的整型。但是一个字节也表示不了所有的整数，如果整数值超过一个字节所能表示的范围，就只能通过 ldc 这条指令了，这条指令带有一个字节的嵌入式操作数，它代表的是一个指向运行时常量池中 Constant_Integer_info 类型常量的索引，通过索引的方式引用运行时常量池中的整数，再大的整数也不怕了。

### 3.3 本地方法栈

本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C＋＋中，你可以用extern "C"告知C＋＋编译器去调用一个C的函数。

虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，所以具体的虚拟机可以自由实现它。甚至有的虚拟机（比如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。

对于一个运行中的Java程序而言，它可能会用到一些跟本地方法相关的数据区，当某个线程调用一个本地方法时，它就进入到一个全新的并且不再受虚拟机限制的世界。本地方法可以通过本地方法接口来访问虚拟机的运行时数据区。本地方法本质上依赖于实现，虚拟机实现的设计者们可以自由地决定使用怎样的机制来让Java程序调用本地方法。任何本地方法接口都会使用某种本地方法栈，当线程调用Java时，虚拟机会创建一个新的栈帧并压入Java栈，然而当它调用的是本地方法时，虚拟机会保持Java栈不变，不再在线程的Java栈中压入新的帧，虚拟机只是简单地动态链接并直接调用指定的本地方法。如果某个虚拟机实现的本地方法接口是使用C连接模型的话，那么它的本地方法栈就是C栈。当C程序调用一个C函数时，其栈操作都是确定的。传递给该函数的参数以某个确定的顺序压入栈，它的返回值也以确定的方式传回调用者。同样，这就是虚拟机实现中本地方法栈的行为。很可能本地方法接口需要回调Java虚拟机中的Java方法，在这种情况下，该线程会保存本地方法栈的状态并进入到另一个Java栈。

```Java
public class IHaveNatives
    {
      native public void Native1( int x ) ;
      native static public long Native2() ;
      native synchronized private float Native3( Object o ) ;
      native void Native4( int[] ary ) throws Exception ;
    } 
```

标识符Native可以与所有其他的java标识符连用，但是abstract除外，因为native暗示这些方法是有实现体的，只不过这些实现体是非java的，但是abstract却显然的指明这些方法无实现体。Native与其他Java标识符连用时，其意义同非Native Method方法并无差别。

比如native static表明这个方法可以在不产生类的实例时直接调用，上面的第三个方法用到了native synchronized，JVM在进入这个方法的实现体之前会执行同步锁机制（就像java的多线程。）一个native method方法可以返回任何java类型，包括非基本类型，而且同样可以进行异常控制。这些方法的实现体可以制一个异常并且将其抛出，这一点与java的方法非常相似。当一个native method接收到一些非基本类型时如Object或一个整型数组时，这个方法可以访问这非些基本型的内部，但是这将使这个native方法依赖于你所访问的java类的实现。有一点要牢牢记住：我们可以在一个native method的本地实现中访问所有的java特性，但是这要依赖于你所访问的java特性的实现，而且这样做远远不如在java语言中使用那些特性方便和容易。  native method的存在并不会对其他类调用这些本地方法产生任何影响，实际上调用这些方法的其他类甚至不知道它所调用的是一个本地方法。JVM将控制调用本地方法的所有细节。需要注意当我们将一个本地方法声明为final的情况。用java实现的方法体在被编译时可能会因为内联而产生效率上的提升。但是一个native final方法是否也能获得这样的好处却是值得怀疑的，但是这只是一个代码优化方面的问题，对功能实现没有影响。
 如果一个含有本地方法的类被继承，子类会继承这个本地方法并且可以用java语言重写这个方法（这个似乎看起来有些奇怪），同样的如果一个本地方法被fianl标识，它被继承后不能被重写。

【为什么要使用Native Method】

java使用起来非常方便，然而有些层次的任务用java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。有时java应用需要与java外面的环境交互。这是本地方法存在的主要原因，你可以想想java需要与一些底层系统如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解java应用之外的繁琐的细节。JVM支持着java语言本身和运行时库，它是java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎 样，它毕竟不是一个完整的系统，它经常依赖于一些底层（underneath在下面的）系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的，还有，如果我们要使用一些java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread 的 setPriority()方法是用java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 SetPriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。

【JVM执行Native Method方法】

我们知道，当一个类第一次被使用到时，这个类的字节码会被加载到内存，并且只会回载一次。在这个被加载的字节码的入口维持着一个该类所有方法描述符的list，这些方法描述符包含这样一些信息：方法代码存于何处，它有哪些参数，方法的描述符（public之类）等等。
  如果一个方法描述符内有native，这个描述符块将有一个指向该方法的实现的指针。这些实现在一些DLL文件内，但是它们会被操作系统加载到java程序的地址空间。当一个带有本地方法的类被加载时，其相关的DLL并未被加载，因此指向方法实现的指针并不会被设置。当本地方法被调用之前，这些DLL才会被加载，这是通过调用java.system.loadLibrary()实现的。

### 3.4 堆

Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。它是被所有线程共享的一块内存区域，在虚拟机启动时创建。它就是用来存放对象实例的，几乎所有的对象实例都在这里分配内存。

堆是垃圾收集器管理的主要区域，如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度看，线程共享的堆中又可能划分出多个线程私有的分配缓存区（Thread Local Allocation Buffer，TLAB）。

根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。

- Yong（新生代）1/3堆空间（复制算法）
  - Eden（8/10）
  - Survivor（2/10）
    - From（1/10）
    - To（1/10）
- Old（老年代）2/3堆空间（标记清除算法）

【参数设置】
堆的大小可以通过参数 –Xms、-Xmx 来指定
新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )
Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )

JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。

几乎所有的对象实例都要再堆上分配，但随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。

【栈上分配】

在我们的应用程序中，其实有很多的对象的作用域都不会逃逸出方法外，也就是说该对象的生命周期会随着方法的调用开始而开始，方法的调用结束而结束，对于这种对象，是不是该考虑将对象不在分配在堆空间中呢？

因为一旦分配在堆空间中，当方法调用结束，没有了引用指向该对象，该对象就需要被gc回收，而如果存在大量的这种情况，对gc来说无疑是一种负担。

因此，JVM提供了一种叫做栈上分配的概念，针对那些作用域不会逃逸出方法的对象，在分配内存时不在将对象分配在堆内存中，而是将对象属性打散后分配在栈（线程私有的，属于栈内存）上，这样，随着方法的调用结束，栈空间的回收就会随着将栈上分配的打散后的对象回收掉，不再给gc增加额外的无用负担，从而提升应用程序整体的性能。

栈上分配需要开启逃逸分析和标量替换

【逃逸分析】-XX:+DoEscapeAnalysis
逃逸分析的作用就是判断一个对象的作用域有没有可能逃出一个Java方法的作用域。如下面代码所示：

```java
// u对象逃出alloc的作用域，不符合栈上分配的条件
public class OnStackTest(){
    private static User u;
    public static void alloc(){
        u = new User();
    }
}
```

```Java
// u对象没有逃出alloc的作用域，符合栈上分配的条件
public class OnStackTest(){
    public static void alloc(){
        User u = new User();
    }
}
```

【标量替换】-XX：+EliminateAllocations

启动标量替换之后，允许把对象打散分配在栈上，比如User对象有属性id和name属性，在启用标量替换后，user对象的id和name属性会视为局部变量分配在栈上。

注意：逃逸分析和标量替换是栈上分配的前提，所以，在JVM参数中关闭了二者其中一个选项，栈上分配都不会生效。

#### 3.4.1 GC堆

Java 中的堆也是 GC 收集垃圾的主要区域。GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )。
Minor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法。
新生代几乎是所有 Java 对象出生的地方，即 Java 对象申请的内存以及存放都是在这个地方。Java 中的大部分对象通常不需长久存活，具有朝生夕灭的性质。
当一个对象被判定为 "死亡" 的时候，GC 就有责任来回收掉这部分对象的内存空间。新生代是 GC 收集垃圾的频繁区域。

当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳
( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。

 -XX:MaxTenuringThreshold 

但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代。
Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。
现实的生活中，老年代的人通常会比新生代的人 "早死"。堆内存中的老年代(Old)不同于这个，老年代里面的对象几乎个个都是在 Survivor 区域中熬过来的，它们是不会那么容易就 "死掉" 了的。因此，Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长。
另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。

设置 JVM 参数为 -XX:+PrintGCDetails，使得控制台能够显示 GC 相关的日志信息

```java
public static void main(String[] args) {
    Object obj = new Object();
    System.gc();
    System.out.println();
    obj = new Object();
    obj = new Object();
    System.gc();
    System.out.println();
}
```

![img](JVM.assets/Minor-GC2.png)

Full GC 信息与 Minor GC 的信息是相似的，这里就不一个一个的画出来了。
从 Full GC 信息可知，新生代可用的内存大小约为 18M，则新生代实际分配得到的内存空间约为 20M(为什么是 20M? 请继续看下面...)。老年代分得的内存大小约为 42M，堆的可用内存的大小约为 60M。可以计算出： 18432K ( 新生代可用空间 ) + 42112K ( 老年代空间 ) = 60544K ( 堆的可用空间 )
新生代约占堆大小的 1/3，老年代约占堆大小的 2/3。也可以看出，GC 对新生代的回收比较乐观，而对老年代以及方法区的回收并不明显或者说不及新生代。
并且在这里 Full GC 耗时是 Minor GC 的 22.89 倍。

```Java
/**
 * -Xms60m
 * -Xmx60m
 * -Xmn20m
 * -XX:NewRatio=2
 * -XX:SurvivorRatio=8
 * -XX:MaxPerSize=30m
 * -XX:+PrintGCDetails
 * @author gaoming
 * @date 2020/06/25
 **/
public class JVM {
    public static void main(String[] args) {
        new JVM().doTest();
    }
    public void doTest(){
        Integer M = new Integer(1024 * 1024  * 1);
        byte[] bytes = new byte[1*M];
        bytes = null;
        System.gc();
        System.out.println();
        bytes = new byte[1*M];
        bytes = new byte[1*M];
        System.gc();
        System.out.println();
    }
}
```

```
[GC (System.gc()) [PSYoungGen: 3323K->872K(18432K)] 3323K->880K(59392K), 0.0022305 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (System.gc()) [PSYoungGen: 872K->0K(18432K)] [ParOldGen: 8K->660K(40960K)] 880K->660K(59392K), [Metaspace: 3145K->3145K(1056768K)], 0.0065727 secs] [Times: user=0.11 sys=0.00, real=0.01 secs] 

[GC (System.gc()) [PSYoungGen: 2703K->1184K(18432K)] 3363K->1844K(59392K), 0.0009466 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (System.gc()) [PSYoungGen: 1184K->0K(18432K)] [ParOldGen: 660K->1655K(40960K)] 1844K->1655K(59392K), [Metaspace: 3184K->3184K(1056768K)], 0.0101442 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 

Heap
 PSYoungGen      total 18432K, used 819K [0x00000000fec00000, 0x0000000100000000, 0x0000000100000000)
  eden space 16384K, 5% used [0x00000000fec00000,0x00000000fecccea0,0x00000000ffc00000)
  from space 2048K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x0000000100000000)
  to   space 2048K, 0% used [0x00000000ffc00000,0x00000000ffc00000,0x00000000ffe00000)
 ParOldGen       total 40960K, used 1655K [0x00000000fc400000, 0x00000000fec00000, 0x00000000fec00000)
  object space 40960K, 4% used [0x00000000fc400000,0x00000000fc59dfa8,0x00000000fec00000)
 Metaspace       used 3204K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 345K, capacity 388K, committed 512K, reserved 1048576K
```

IDEA J设置VM参数
VM Options

```
-Xms60m -Xmx60m -Xmn20m -XX:NewRatio=2 -XX:SurvivorRatio=8 -XX:+PrintGCDetails
```

#### 3.4.2 TLAB

TLAB（Thread Local Allocation Buffer），即：线程本地分配缓存。这是一块线程专用的内存分配区域，TLAB占用的是Eden区的空间，在TLAB启用的情况下（默认开启），JVM会为每一个线程分配一块TLAB区域。

【为什么需要TLAB】
为了加速对象的分配，由于对象一般分配在堆上，而堆是线程共用的，因此可能会有多个线程在堆上申请空间，而每一次的对象分配都必须线程同步，会使得分配效率下降。考虑到对象分配几乎是Java中最常用的操作，因此JVM使用了TLAB这样的线程专有区域来避免多线程冲突，提高对象分配的效率。

局限性：TLAB空间一般不会太大（占用Eden区），所以大对象无法进行TLAB分配，只能直接分配到堆上。

分配策略：一个100kb的TLAB区域，如果已经使用了80kb，当需要分配一个30kb的对象时，TLAB是如何分配的呢？此时，虚拟机有两种选择：第一，废弃当前的TLAB（会浪费20kb的空间），第二，将这个30kb的对象直接分配到堆上，保留当前TLAB（当有小于20kb的对象请求TLAB分配时可以直接使用该TLAB区域）

JVM选择策略：在虚拟机内部维护一个叫refill_waste的值，当请求对象大于refill_waste时，会选择在堆中分配，反之，则会废弃当前TLAB，新建TLAB来分配对象。默认情况下，TLAB和refill_waste都是会在运行时不断调整的，使得系统的运行状态达到最优。

| 参数                         | 作用                     | 备注                                                         |
| ---------------------------- | ------------------------ | ------------------------------------------------------------ |
| -XX：+UserTLAB               | 启用TLAB                 | 默认启用                                                     |
| -XX：TLABRefillWasteFraction | 设置允许空间浪费的比例   | 默认值：64，即使用1/64的 TLAB空间大小<br />作为refill_waste的值 |
| -XX：ResizeTLAB              | 禁止系统自动调整TLAB大小 |                                                              |
| -XX：TLABSize                | 指定TLAB大小             | 单位：B                                                      |

### 4 方法区

方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。

### 内存溢出异常

如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常，让我们写一段代码，使其抛出该异常

```Java
/**
 * VM Args: -Xss128k
 */
public class JVMStackSOF {
    private int stackLength = 1;
    public void stackLeak() {
        stackLength++;
        stackLeak();
    }
    public static void main(String[] args) {
        JVMStackSOF sof = new JVMStackSOF();
        try {
            sof.stackLeak();
        } catch (Throwable e) {
            System.out.println("Stack length:" + sof.stackLength);
            throw e;
        }
    }
}
```

在运行之前，设置JVM的参数为-Xss128k，运行结果如下

```
Stack length:1002
Exception in thread "main" java.lang.StackOverflowError
    at OneMoreStudy.JVMStackSOF.stackLeak(JVMStackSOF.java:10)
    at OneMoreStudy.JVMStackSOF.stackLeak(JVMStackSOF.java:11)
    at OneMoreStudy.JVMStackSOF.stackLeak(JVMStackSOF.java:11)
......
```

栈的深度达到1002时，抛出了StackOverflowError异常。

如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常，还是让我们写一段代码，使其抛出该异常：

```Java
/**
 * VM Args: -Xss2M
 */
public class JVMStackOOM {
    private void dontStop() {
        while (true) {

        }
    }

    public void stackLeakByThread() {
        while (true) {
            Thread t = new Thread(new Runnable() {
                public void run() {
                    dontStop();
                }
            });
            t.start();
        }
    }

    public static void main(String[] args) {
        JVMStackOOM oom = new JVMStackOOM();
        oom.stackLeakByThread();
    }
}
```

这段代码会创建出无限多的线程，因为Java的线程会映射系统的内核线程上，所以会造成CPU占用率100%，系统假死等现象，**请谨慎运行**。在运行之前，设置JVM的参数为-Xss2M，运行很长一段时间后结果如下：

```java
Exception in thread "main" java.lang.OutMemoryError: unable to create new native thread
    at java.lang.Thread.start0(Native Method)
    at java.lang.Thread.start(Unknown Source)
    at OneMoreStudy.JVMStackOOM.stackLeakByThread(JVMStackOOM.java:18)
    at OneMoreStudy.JVMStackOOM.main(JVMStackOOM.java:24)
```

https://mp.weixin.qq.com/s/izbCCfOlw0-mcnOqpc3WKw

https://zhuanlan.zhihu.com/p/102065453

## 4 JVM 参数选项

| 参数                            | 备注                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| -Xms                            | 初始堆大小，如-Xms256m                                       |
| -Xmx                            | 最大堆大小，如-Xmx512m                                       |
| -Xmn                            | 新生代大小。通常为 Xmx 的 1/3 或 1/4。<br />新生代 = Eden + 2 个 Survivor 空间。<br />实际可用空间为 = Eden + 1 个 Survivor，即 90% |
| -Xss                            | JDK1.5+ 每个线程堆栈大小为 1M，<br />一般来说如果栈不是很深的话， 1M 是绝对够用了的。 |
| -XX:NewRatio                    | 新生代与老年代的比例，如 –XX:NewRatio=2，<br />则新生代占整个堆空间的1/3，老年代占2/3 |
| -XX:SurvivorRatio               | 新生代中 Eden 与 Survivor 的比值。默认值为 8。<br />即 Eden 占新生代空间的 8/10，另外两个 Survivor 各占 1/10 |
| -XX:PermSize                    | 永久代(方法区)的初始大小（8.0已移除）                        |
| -XX:MaxPermSize                 | 永久代(方法区)的最大值                                       |
| -XX:+PrintGCDetails             | 打印 GC 信息                                                 |
| -XX:+HeapDumpOnOutOfMemoryError | 让虚拟机在发生内存溢出时 Dump 出当前的内存堆转储快照，<br />以便分析用 |