# 数组
## 1. leetcode41- 缺失的第一个正数      **
### 题目描述
给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。
进阶：你可以实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案吗？

输入：nums = [1,2,0]
输出：3

### 代码
```c++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            while (nums[i] != i + 1) {
                if ((nums[i] <= 0) || (nums[i] >= n) || (nums[i] == nums[nums[i] - 1])) {
                    break;
                }
                swap(nums[i], nums[nums[i] - 1]);
            }            
        }
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }

        return n + 1;
    }
};
```

## 2. leetcode54 - 螺旋矩阵   **
### 题目描述
给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。

![image](https://user-images.githubusercontent.com/36949881/115045934-8af89100-9f09-11eb-942d-656b6feb0136.png)


### 代码
```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix)
    {
        vector<int> ret;
        if (matrix.empty()) {
            return ret;
        }
        int rows = matrix.size();
        int columns = matrix[0].size();
        vector<vector<bool>> visited(rows, vector<bool>(columns));
        int total = rows * columns;

        int row = 0;
        int column = 0;
        int directionIndex = 0;
        for (int i = 0; i < total; i++) {
            ret.push_back(matrix[row][column]);
            visited[row][column] = true;
            int nextRow = row + directions[directionIndex][0];
            int nextColumn = column + directions[directionIndex][1];
            bool flag = (nextRow < 0) || (nextRow >= rows) || (nextColumn < 0) ||
                (nextColumn >= columns) || (visited[nextRow][nextColumn]);
            if (flag) {
                directionIndex = (directionIndex + 1) % 4;
            }
            row += directions[directionIndex][0];
            column += directions[directionIndex][1];
        }
        return ret;
    }
private:
    int directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
};
```

## 3. leetcode56 - 合并区间   **
### 题目描述
以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

输入：intervals = [[1,3],[2,6],[8,10],[15,18]]

输出：[[1,6],[8,10],[15,18]]

解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].


### 代码
```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> ans;
        sort(intervals.begin(), intervals.end(), [](vector<int> a, vector<int> b){
            return a[0] < b[0];
        });

        int start = intervals[0][0];
        int end = intervals[0][1];
        int i = 1;
        while (i < intervals.size()) {
            if (end >= intervals[i][0]) {
                end = max(end, intervals[i][1]);
            } else {
                ans.push_back({start, end});
                start = intervals[i][0];
                end = intervals[i][1];
            }
            i++;
        }
        ans.push_back({start, end});

        return ans;
    }
};

```

## 4. leetcode57 - 插入区间   **
### 题目描述
给你一个 无重叠的 ，按照区间起始端点排序的区间列表。

在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。

输入：intervals = [[1,3],[6,9]], newInterval = [2,5]

输出：[[1,5],[6,9]]
### 解题思路
![image](https://user-images.githubusercontent.com/36949881/116121503-40d69300-a6f3-11eb-8113-e61c74e0b99f.png)

### 代码
```c++
class Solution {
public:
    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
        vector<vector<int>> ans;
        int n = intervals.size();
        if (intervals.size() == 0) {
            ans.push_back(newInterval);
            return ans;
        }
        
        int i = 0;
        while ((i < n) && (intervals[i][1] < newInterval[0])) {
            ans.push_back(intervals[i]);
            i++;
        }
        
        if (i < n) {
            int left = min(newInterval[0], intervals[i][0]);
            int right = newInterval[1];
            while ((i < n) && (intervals[i][0] <= right)) {
                right = max(intervals[i][1], right);
                i++;
            }
            ans.push_back({left, right});
            while (i < n) {
                ans.push_back(intervals[i]);
                i++;
            }
        } else {
            ans.push_back(newInterval);
        }

        return ans;
    }
};
```

